<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>사다리 게임</title>
  <style>
    :root{
      --bg:#0b1020; --panel:#121933; --ink:#e9f0ff; --muted:#9fb2d0; --accent:#7aa2ff; --accent2:#22c55e;
    }
    *{box-sizing:border-box}
    body{margin:0;min-height:100vh;background:radial-gradient(1200px 600px at 20% -10%,#1a1f35 0%,#090e1f 60%,#040614 100%);color:var(--ink);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    header{padding:16px 20px;display:flex;justify-content:space-between;align-items:center}
    .wrap{display:grid;grid-template-columns:360px 1fr;gap:16px;padding:0 20px 20px}
    @media (max-width:960px){.wrap{grid-template-columns:1fr}}
    .panel{background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(0,0,0,.06)),var(--panel);border:1px solid rgba(255,255,255,.08);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .left{padding:16px;position:sticky;top:12px}
    .left h2{margin:0 0 12px;color:var(--accent)}
    .control{margin:10px 0}
    .control label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px}
    input[type="text"],input[type="number"],select{width:100%;padding:10px;border-radius:10px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);color:var(--ink)}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .btn{width:100%;padding:12px 16px;border-radius:12px;border:1px solid rgba(255,255,255,.12);color:#fff;font-weight:800;background:linear-gradient(180deg,#2d46a3,#193074);cursor:pointer;box-shadow:0 6px 16px rgba(14,27,74,.6)}
    .btn.alt{background:linear-gradient(180deg,#394866,#1f2a40)}
    .btn.green{background:linear-gradient(180deg,#2bb24a,#167a2f)}
    .row{display:flex;gap:8px}
    .tag{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);padding:8px 10px;border-radius:10px}
    .list{display:grid;gap:6px}
    .list input{width:100%}
    .small{font-size:12px;color:var(--muted)}

    .stage{padding:16px;display:grid;gap:10px}
    .canvasWrap{position:relative;min-height:480px;display:grid;place-items:center;padding:10px}
    svg{width:100%;height:520px;display:block}
    .legend{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .legend .key{display:inline-flex;gap:6px;align-items:center;color:var(--muted);font-size:12px}
    .legend .box{width:10px;height:10px;border-radius:2px}

    .result{padding:12px;border-top:1px solid rgba(255,255,255,.06);max-height:200px;overflow:auto}
    .result p{margin:6px 0;color:var(--muted)}
  </style>
</head>
<body>
  <header>
    <div style="font-weight:800">🔀 사다리 게임</div>
    <div class="small">참가자와 결과를 입력하고 사다리를 생성하세요</div>
  </header>

  <div class="wrap">
    <section class="panel left">
      <h2>설정</h2>
      <div class="control">
        <label>참가자 수</label>
        <select id="count">
          <option>2</option><option>3</option><option selected>4</option><option>5</option><option>6</option><option>7</option><option>8</option>
        </select>
      </div>

      <div class="grid">
        <div class="control">
          <label>세로선 길이</label>
          <select id="height">
            <option value="360">짧음</option>
            <option value="480" selected>중간</option>
            <option value="600">길음</option>
          </select>
        </div>
        <div class="control">
          <label>가로발판 밀도</label>
          <select id="density">
            <option value="low">낮음</option>
            <option value="mid" selected>중간</option>
            <option value="high">높음</option>
          </select>
        </div>
      </div>

      <div class="grid">
        <div class="control">
          <label>애니메이션 속도</label>
          <select id="speed">
            <option value="slow">느림</option>
            <option value="normal" selected>보통</option>
            <option value="fast">빠름</option>
          </select>
        </div>
        <div class="control">
          <label>씨드 (옵션)</label>
          <input id="seed" type="text" placeholder="랜덤 고정값" />
        </div>
      </div>

      <div class="control">
        <label>참가자 이름</label>
        <div class="list" id="names"></div>
      </div>

      <div class="control">
        <label>바닥 결과</label>
        <div class="list" id="goals"></div>
        <div class="small">결과가 비어 있으면 1, 2, 3처럼 자동 생성</div>
      </div>

      <div class="row" style="margin-top:8px">
        <button class="btn" id="gen">사다리 생성</button>
        <button class="btn alt" id="shuffle">결과 섞기</button>
      </div>
      <div class="row" style="margin-top:8px">
        <button class="btn green" id="runAll">모두 내려가기</button>
        <button class="btn alt" id="clear">초기화</button>
      </div>
    </section>

    <section class="panel stage">
      <div class="legend">
        <span class="key"><span class="box" style="background:#7aa2ff"></span>세로선</span>
        <span class="key"><span class="box" style="background:#22c55e"></span>가로발판</span>
        <span class="key"><span class="box" style="background:#facc15"></span>이동 경로</span>
      </div>
      <div class="canvasWrap">
        <svg id="ladder" viewBox="0 0 900 560" preserveAspectRatio="xMidYMid meet"></svg>
      </div>
      <div class="result" id="result"></div>
    </section>
  </div>

  <script>
    // Utilities
    function mulberry32(a){return function(){var t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296 }}
    function hashSeed(str){let h=1779033703^str.length;for(let i=0;i<str.length;i++){h=Math.imul(h^str.charCodeAt(i),3432918353);h=h<<13|h>>>19;}return h>>>0}

    const svg = document.getElementById('ladder');
    const namesBox = document.getElementById('names');
    const goalsBox = document.getElementById('goals');
    const countSel = document.getElementById('count');
    const heightSel = document.getElementById('height');
    const densitySel = document.getElementById('density');
    const seedInput = document.getElementById('seed');
    const speedSel = document.getElementById('speed');
    const genBtn = document.getElementById('gen');
    const runBtn = document.getElementById('runAll');
    const shuffleBtn = document.getElementById('shuffle');
    const clearBtn = document.getElementById('clear');
    const resultBox = document.getElementById('result');

    // Initial fields
    function rebuildFields(){
      namesBox.innerHTML='';
      goalsBox.innerHTML='';
      const n = Number(countSel.value);
      const defaults = ['A','B','C','D','E','F','G','H'];
      for(let i=0;i<n;i++){
        const ni = document.createElement('input');
        ni.type='text'; ni.value = defaults[i] || `P${i+1}`; ni.dataset.idx=i;
        namesBox.appendChild(ni);
        const gi = document.createElement('input');
        gi.type='text'; gi.placeholder = `결과 ${i+1}`; gi.dataset.idx=i;
        goalsBox.appendChild(gi);
      }
    }
    rebuildFields();
    countSel.addEventListener('change', rebuildFields);

    function getNames(){
      return Array.from(namesBox.querySelectorAll('input')).map(i=>i.value.trim()||`P${Number(i.dataset.idx)+1}`)
    }
    function getGoals(){
      const arr = Array.from(goalsBox.querySelectorAll('input')).map((i,idx)=>i.value.trim()||`${idx+1}`);
      return arr;
    }

    // Ladder model
    let model = null; // {cols, rows, rungs, width, height, startX, topY, bottomY}

    function generateLadder(){
      const cols = Number(countSel.value);
      const height = Number(heightSel.value);
      const width = 860; // inner width
      const left = 40, right = width-40;
      const top = 40, bottom = Math.min(520-40, Number(heightSel.value));
      const colX = [];
      for(let i=0;i<cols;i++) colX.push(left + i*(right-left)/(cols-1));

      // density controls number of rows and rung attempts
      const density = densitySel.value; // low mid high
      const rowCount = density==='low'? 9 : density==='mid'? 12 : 16;

      // RNG
      let rng = Math.random;
      const s = seedInput.value.trim();
      if(s){rng = mulberry32(hashSeed(s));}

      const rowsY = [];
      for(let r=0;r<rowCount;r++) rowsY.push(top + (r+1)*(bottom-top)/(rowCount+1));

      // Create rungs with constraints: no adjacent rungs connecting same pair at same row, and no touching neighbors in immediate next row
      const rungs = []; // each {c: left column index, y}
      for(const y of rowsY){
        // attempt to place between neighboring columns
        for(let c=0;c<cols-1;c++){
          const p = rng();
          const threshold = density==='low'? 0.28 : density==='mid'? 0.44 : 0.6;
          if(p < threshold){
            // avoid placing if previous row had rung adjacent at same columns
            const prev = rungs.findLast? rungs.findLast(g=>Math.abs(g.y - y) < 18 && Math.abs(g.c - c) <= 1)
                                       : [...rungs].reverse().find(g=>Math.abs(g.y - y) < 18 && Math.abs(g.c - c) <= 1);
            if(prev) continue;
            rungs.push({c,y});
          }
        }
      }

      model = {cols, width, height:bottom+40, left, right, top, bottom, colX, rungs};
      drawLadder();
      resultBox.innerHTML = '';
    }

    function drawLadder(){
      if(!model) return;
      const {cols,left,right,top,bottom,colX,rungs,height} = model;
      svg.setAttribute('viewBox', `0 0 900 ${height}`);
      svg.innerHTML = '';
      // verticals
      for(let i=0;i<cols;i++){
        const line = lineEl(colX[i], top, colX[i], bottom, '#7aa2ff', 3);
        svg.appendChild(line);
        // top name
        const tn = textEl(colX[i], top-16, getNames()[i], 'middle');
        svg.appendChild(tn);
        // bottom goal
        const gb = textEl(colX[i], bottom+18, getGoals()[i] || String(i+1), 'middle');
        svg.appendChild(gb);
      }
      // rungs
      for(const r of rungs){
        const x1 = colX[r.c], x2 = colX[r.c+1];
        const y = r.y;
        svg.appendChild(lineEl(x1, y, x2, y, '#22c55e', 4));
      }
    }

    function lineEl(x1,y1,x2,y2,stroke,w){
      const l = document.createElementNS('http://www.w3.org/2000/svg','line');
      l.setAttribute('x1',x1);l.setAttribute('y1',y1);l.setAttribute('x2',x2);l.setAttribute('y2',y2);
      l.setAttribute('stroke',stroke);l.setAttribute('stroke-width',w);
      l.setAttribute('stroke-linecap','round');
      return l;
    }
    function circleEl(cx,cy,r,fill){
      const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
      c.setAttribute('cx',cx);c.setAttribute('cy',cy);c.setAttribute('r',r);c.setAttribute('fill',fill);
      return c;
    }
    function pathEl(d,stroke,w){
      const p = document.createElementNS('http://www.w3.org/2000/svg','path');
      p.setAttribute('d',d);p.setAttribute('fill','none');p.setAttribute('stroke',stroke);p.setAttribute('stroke-width',w);
      p.setAttribute('stroke-linecap','round');p.setAttribute('stroke-linejoin','round');
      return p;
    }
    function textEl(x,y,txt,anchor){
      const t = document.createElementNS('http://www.w3.org/2000/svg','text');
      t.setAttribute('x',x); t.setAttribute('y',y); t.setAttribute('text-anchor',anchor||'start');
      t.setAttribute('font-size','14'); t.setAttribute('fill','#e9f0ff'); t.textContent = txt; return t;
    }

    function shuffleGoals(){
      const inputs = Array.from(goalsBox.querySelectorAll('input'));
      const vals = inputs.map((i,idx)=>i.value.trim()||`${idx+1}`);
      // Fisher Yates
      for(let i=vals.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [vals[i],vals[j]] = [vals[j],vals[i]];
      }
      inputs.forEach((i,idx)=>i.value = vals[idx]);
      drawLadder();
    }

    // Compute mapping for a given start index
    function traverse(startIdx){
      const {colX, rungs, top, bottom} = model;
      let xIdx = startIdx;
      let y = top;
      const pathPoints = [[colX[xIdx], y]];
      // sort rungs by y
      const sorted = [...rungs].sort((a,b)=>a.y-b.y);
      for(const r of sorted){
        const nextY = r.y;
        // move down to rung
        pathPoints.push([colX[xIdx], nextY]);
        // if rung connects current index
        if(r.c === xIdx){
          // go right
          pathPoints.push([colX[xIdx+1], nextY]);
          xIdx = xIdx+1;
        } else if(r.c === xIdx-1){
          // go left
          pathPoints.push([colX[xIdx-1], nextY]);
          xIdx = xIdx-1;
        }
        y = nextY;
      }
      // go to bottom
      pathPoints.push([colX[xIdx], bottom]);
      return {endIdx:xIdx, pathPoints};
    }

    function drawPath(points,color){
      const d = points.map((p,i)=> (i? 'L':'M')+p[0]+','+p[1]).join(' ');
      const p = pathEl(d, color, 4);
      p.setAttribute('stroke-dasharray','6 6');
      svg.appendChild(p);
      const head = points[points.length-1];
      svg.appendChild(circleEl(head[0], head[1], 4, color));
      return p;
    }

    async function animateTraverse(startIdx, color){
      const {pathPoints, endIdx} = traverse(startIdx);
      // animate a dot along the path
      const dot = circleEl(pathPoints[0][0], pathPoints[0][1], 6, color);
      dot.setAttribute('opacity','0.95');
      svg.appendChild(dot);
      const speed = speedSel.value==='slow'? 900 : speedSel.value==='fast'? 300 : 550; // ms per segment
      for(let i=1;i<pathPoints.length;i++){
        const [x1,y1]=pathPoints[i-1];
        const [x2,y2]=pathPoints[i];
        const t0 = performance.now();
        let done=false; while(!done){
          const t = (performance.now()-t0)/speed;
          if(t>=1){dot.setAttribute('cx',x2); dot.setAttribute('cy',y2); done=true;}
          else {dot.setAttribute('cx', x1+(x2-x1)*t); dot.setAttribute('cy', y1+(y2-y1)*t);} await new Promise(r=>requestAnimationFrame(r));
        }
      }
      return endIdx;
    }

    function showPairs(pairs){
      resultBox.innerHTML = '';
      pairs.forEach(p=>{
        const line = document.createElement('p');
        line.textContent = `${p.name} -> ${p.goal}`;
        resultBox.appendChild(line);
      })
    }

    // Event handlers
    genBtn.addEventListener('click', generateLadder);
    shuffleBtn.addEventListener('click', shuffleGoals);
    clearBtn.addEventListener('click', ()=>{ svg.innerHTML=''; resultBox.innerHTML=''; model=null; });

    runBtn.addEventListener('click', async ()=>{
      if(!model) generateLadder();
      const names = getNames();
      const goals = getGoals();
      const colors = ['#facc15','#60a5fa','#34d399','#f472b6','#a78bfa','#fb923c','#f87171','#4ade80'];
      const pairs = [];
      // Clear previous path overlays only (keep ladder)
      drawLadder();
      for(let i=0;i<model.cols;i++){
        const endIdx = await animateTraverse(i, colors[i%colors.length]);
        pairs.push({name:names[i], goal:goals[endIdx]});
      }
      showPairs(pairs);
    });

    // Generate once at load
    generateLadder();
  </script>
</body>
</html>